package a46.cryptokey;
//TODO pensar qual a melhor distribuicao por packages
import java.nio.ByteBuffer;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

//RFC4226
class HOTP {

    private KeyManager _keyManager;
    private String _secretKey;
    private static final String MAC_ALGORITHM = "HmacSHA1"; //HmacSHA1 returns a 160bit (20bytes) message digest
    private int _numberDigitsOTP;

    public HOTP(String secretKey, int numberDigitsOTP) {
        _numberDigitsOTP = numberDigitsOTP;
        _keyManager = new KeyManager();
        _secretKey = secretKey;
    }

    public void set_secretKey(String secretKey) {
        _secretKey = secretKey;
    }

    protected String generateOTP(long counter) {
        if (_secretKey == null) {
            return ""; //The UI activity will interpret this as no key was already created
        }

        //TODO transformation of key and counter for byte array
        byte[] key = _keyManager.hexStringToBytes(_secretKey); //TODO ter em atencao a
        byte[] counterByte = ByteBuffer.allocate(8).putLong(counter).array(); //Long to byte array

        byte[] hmacHash = hmacHash(key, counterByte);

        // This piece of code is used in TOTP for truncate de hash value of 20 bytes generated by de hmacSHA-1
        // This truncated value will be the final one time password
        int offset = hmacHash[hmacHash.length-1] & 0xf;
        int truncatedHash = (hmacHash[offset++] & 0x7f) << 24 |
                            (hmacHash[offset++] & 0xff) << 16 |
                            (hmacHash[offset++] & 0xff) << 8 |
                            (hmacHash[offset] & 0xff);
        int otp = (truncatedHash % (int)(Math.pow(10, _numberDigitsOTP)));

        String finalOTP = Integer.toString(otp);
        //Get to the desired size in those rare cases where the modulo had given us one digit less
        while(finalOTP.length() < _numberDigitsOTP) {
            finalOTP = "0" + finalOTP;
        }

        return finalOTP;
    }

    private byte[] hmacHash(byte[] secret, byte[] counter) {
        byte[] digest = null;

        Mac mac;
        try {
            mac = Mac.getInstance(MAC_ALGORITHM);

            SecretKey secretKey = new SecretKeySpec(secret, MAC_ALGORITHM);

            mac.init(secretKey);

            digest = mac.doFinal(counter);

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            //TODO deal with exception
        } catch (InvalidKeyException e) {
            e.printStackTrace();
            //TODO deal with exception
        }

        return digest;
    }
}
